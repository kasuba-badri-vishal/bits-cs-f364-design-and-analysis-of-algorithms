.TH "src/ford-fulkerson.cpp" 3 "Thu Apr 23 2020" "DAA Assignment 2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/ford-fulkerson.cpp
.SH SYNOPSIS
.br
.PP
\fC#include <bits/stdc++\&.h>\fP
.br
\fC#include <sys/resource\&.h>\fP
.br
\fC#include <chrono>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBfindPath\fP (vector< pair< pair< int, int >, char >> Res[], int src, int sink, int parent[], int nVer)"
.br
.RI "This Program is the implementation the 'Ford-Fulkerson' algorithm to find the maximum flow and minimum cut\&. "
.ti -1c
.RI "int \fBfindMinCut\fP (vector< pair< pair< int, int >, char >> Res[], vector< pair< int, int > > Capacity[], int src, int nVer)"
.br
.RI "This function finds an s-t cut of minimum capacity between the two partitions\&. "
.ti -1c
.RI "int \fBfindBottleNeck\fP (vector< pair< pair< int, int >, char >> Res[], int source, int sink, int parent[], int nVer)"
.br
.RI "This function finds the bottleneck capacity in all paths between source and sink\&. "
.ti -1c
.RI "void \fBfordFulkerson\fP (vector< pair< int, int > > Capacity[], vector< pair< int, int > > Flow[], vector< pair< pair< int, int >, char >> Res[], int src, int sink, int nVer)"
.br
.RI "This function implements the ford-fulkerson's algorithms to find maxflow-mincut of a graph\&. "
.ti -1c
.RI "void \fBBipartiteMatching\fP ()"
.br
.RI "This function implements bipartite matching using ford-fulkerson algorithm\&. "
.ti -1c
.RI "int \fBmain\fP ()"
.br
.RI "This is the main function\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBBipar\fP = 0"
.br
.ti -1c
.RI "int \fBnVSet1\fP =0"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void BipartiteMatching ()"

.PP
This function implements bipartite matching using ford-fulkerson algorithm\&. The input is used to construct the residual graph (Res) and then fordfulkerson() function is run on it\&.
.PP
\fBReturns\fP
.RS 4
none\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBfordFulkerson()\fP 
.br
 
.RE
.PP

.SS "int findBottleNeck (vector< pair< pair< int, int >, char >> Res[], int source, int sink, int parent[], int nVer)"

.PP
This function finds the bottleneck capacity in all paths between source and sink\&. 
.PP
\fBParameters\fP
.RS 4
\fIRes\fP : an array of vectors\&. Each vector is a pair of pair<int, int> and char\&. 
.br
\fICapacity\fP : an array of vectors\&. Each vector is a pair of integers\&. 
.br
\fIsrc\fP : an integer, source node\&. 
.br
\fIsink\fP : an integer, sink node\&. 
.br
\fIparent\fP : array of parent nodes\&. 
.br
\fInVer\fP : number of vertices\&. 
.RE
.PP
\fBReturns\fP
.RS 4
integer\&. the bottleneck capactiy\&. 
.RE
.PP

.SS "int findMinCut (vector< pair< pair< int, int >, char >> Res[], vector< pair< int, int > > Capacity[], int src, int nVer)"

.PP
This function finds an s-t cut of minimum capacity between the two partitions\&. Flow is always limited by capacity of S-T cut edges max flow and min cut are same flow in edges from A to B is full capacity and B to A is 0
.PP
\fBParameters\fP
.RS 4
\fIRes\fP : an array of vectors\&. Each vector is a pair of pair<int, int> and char\&. 
.br
\fICapacity\fP : an array of vectors\&. Each vector is a pair of integers\&. 
.br
\fIsrc\fP : an integer, source node\&. 
.br
\fInVer\fP : number of vertices\&. 
.RE
.PP
\fBReturns\fP
.RS 4
integer\&. minimum capacity\&. 
.RE
.PP

.SS "bool findPath (vector< pair< pair< int, int >, char >> Res[], int src, int sink, int parent[], int nVer)"

.PP
This Program is the implementation the 'Ford-Fulkerson' algorithm to find the maximum flow and minimum cut\&. This function finds if a path exists between source node and sink node using BFS\&.
.PP
Initialize parent array before calling BFS function
.PP
\fBParameters\fP
.RS 4
\fIRes\fP : an array of vectors\&. Each vector is a pair of pair<int, int> and char\&. 
.br
\fIsrc\fP : an integer, source node\&. 
.br
\fIsink\fP : an integer, sink node\&. 
.br
\fIparent\fP : array of parent nodes\&. 
.br
\fInVer\fP : number of vertices\&. 
.RE
.PP
\fBReturns\fP
.RS 4
boolean\&. True if a path is found else False\&. 
.RE
.PP

.SS "void fordFulkerson (vector< pair< int, int > > Capacity[], vector< pair< int, int > > Flow[], vector< pair< pair< int, int >, char >> Res[], int src, int sink, int nVer)"

.PP
This function implements the ford-fulkerson's algorithms to find maxflow-mincut of a graph\&. 
.PP
\fBParameters\fP
.RS 4
\fICapacity\fP : an array of vectors\&. Each vector is a pair of integers (edge)\&. Represents capacity of edges\&. 
.br
\fIFlow\fP : an array of vectors\&. Each vector is a pair of integers (edge)\&. Represents flow of edges\&. 
.br
\fIRes\fP : an array of vectors\&. Each vector is a pair of pair<int, int> and char\&. 
.br
\fIsrc\fP : an integer, source node\&. 
.br
\fIsink\fP : an integer, sink node\&. 
.br
\fInVer\fP : number of vertices\&. 
.RE
.PP
\fBReturns\fP
.RS 4
none 
.RE
.PP

.SS "int main ()"

.PP
This is the main function\&. A residual graph is constructed using the data from input\&.
.PP
\fBReturns\fP
.RS 4
integer, 0\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBfordFulkerson()\fP \fBBipartiteMatching()\fP 
.RE
.PP
\fBNote\fP
.RS 4
We have used \fIhigh_resolution_clock\fP for finding the time taken for the entire program to run\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "int Bipar = 0"

.SS "int nVSet1 =0"

.SH "Author"
.PP 
Generated automatically by Doxygen for DAA Assignment 2 from the source code\&.
