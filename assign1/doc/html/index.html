<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DAA Assignment 1: Kosaraju Algorithm and Divide and Conquer Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DAA Assignment 1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Kosaraju Algorithm and Divide and Conquer Algorithm </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Two different algorithms have been implemented to find the Strongly Connected Components</p>
<p>1) Kosaraju's Algorithm.</p><ul>
<li>This algorithm uses topological sort and dfs to find Strongly Connected Components of a given graph.</li>
</ul>
<div class="fragment"><div class="line">For each vertex u of the graph, mark u as unvisited. Let L be empty.</div>
<div class="line">For each vertex u of the graph do Visit(u), where Visit(u) is the recursive subroutine:</div>
<div class="line">    If u is unvisited then:</div>
<div class="line">        Mark u as visited.</div>
<div class="line">        For each out-neighbour v of u, do Visit(v).</div>
<div class="line">        Prepend u to L.</div>
<div class="line">    Otherwise do nothing.</div>
<div class="line">For each element u of L in order, do Assign(u,u) where Assign(u,root) is the recursive subroutine:</div>
<div class="line">    If u has not been assigned to a component then:</div>
<div class="line">        Assign u as belonging to the component whose root is root.</div>
<div class="line">        For each in-neighbour v of u, do Assign(v,root).</div>
<div class="line">    Otherwise do nothing.</div>
</div><!-- fragment --><p>2) Divide and Conquer Algorithm.</p><ul>
<li>This algorithm follows a divide and conquer approach to divide the set of vertices into multiple disjoint sets and work on each set individually. The algorithm requires a function to find predecessors and descendents of a vertex.</li>
</ul>
<div class="fragment"><div class="line">DCSC(G)</div>
<div class="line">    If G has no edges then</div>
<div class="line">        forall v in V Output {v}.</div>
<div class="line">    Else</div>
<div class="line">        Select a random vertex v from V</div>
<div class="line">        SCC &lt;- Pred(G, v) \ Desc(G, v)</div>
<div class="line">        Output SCC</div>
<div class="line">        DCSC(Pred(G, v) \ SCC)</div>
<div class="line">        DCSC(Desc(G, v) \ SCC)</div>
<div class="line">        DCSC(Rem(G, v))</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
A Comparison and Analysis of the Algorithms</h3>
<ol type="1">
<li>We can find all strongly connected components in O(m+n) time, where 'n' is the number of vertices &amp; 'm' is the number of edges, using Kosaraju’s algorithm. This calculation is asymptotically best calculation, however there are different algorithms like Tarjan's and path based algorithms having same time complexity yet look for strongly connected components utilizing single DFS.</li>
<li>This algorithm runs in O(m log n) time. The worst case (when the descendant set is very large) leads to Θ(mn) runtime. The best case (when the remainder set is very large) leads to Θ(m) runtime. By choosing the pivot vertex arbitrarily, the expected complexity of the algorithm is bounded as Θ(m lg n + n). The modified version has a worst–case complexity of O(m log n). Here, 'n' is the number of vertices and 'm' is the number of edges.</li>
</ol>
<p>If we try to compare the time complexities of the 2 algorithms, either could be the better one depending on the situation. Assuming that they're equal, we have O(n) vs O(n log n), so the algorithm with O(n + m) complexity is faster. If, on the other hand, m is effectively constant while n grows quickly, then we have O(n) vs O(log n), so the second one is better. So, the second is better for large n, and the first is better for cases where both m and n are large. (If m dominates the equation then they're both linear.)</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Applications:</h3>
<p>Algorithms to find strongly connected components are often used as a starting step in many graph algorithms that work only on strongly connected graphs. Another application is that in social networks, a group of people is generally considered a strongly connected component. People belonging to such groups often like similar kinds of pages or play common games. This calculation can be utilized to discover such groups and suggest these commonly preferred pages or games to the individuals in the group who haven't liked these pages or engaged in these games yet. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
